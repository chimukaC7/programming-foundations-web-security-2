Cross-site request forgery (CSRF)


-

- A cross-site request forgery attack is when an attacker tricks a user's browser into sending a request to another site. Cross-site because the attack originates at one site, but sends a request to another site. And request forgery because the request is not a genuine user request. Cross-site request forgery is often shortened to CSRF. Imagine that a hacker wants to get a user to click a link. One way would be to name the link with something deceptive and post it online or send it in an email. The link hides the action, but it still requires a user to click on it. A CSRF attack does not depend on the user clicking a link. Instead, the attacker places the URL into the HTML of a page, most often as the source attribute of an image tag. When the page loads, the browser automatically sends a request for each of the images that are in the HTML. It doesn't matter that this image source will fail to return an image. The request will still be made. Our hacker could place this image on a webpage that they control, or they could put it on a blog comment, a forum post, or an online ad, or they could use it as an avatar or profile picture. Every browser that loads that HTML will send a request to that URL. The user might see a broken image link, but would not know that a forged request was sent. This example shows how to generate fraudulent clicks or votes in an online poll. A more potent example is one which takes advantage of a user's logged in state. Let's imagine that a user logs into their online bank account to pay some bills. The bank's website sets a cookie in the user's browser to indicate that they've been authenticated. Future requests to any page on that bank's website will include that cookie and the proof of authentication. It works a lot like one of those wristbands that you get when you pay to enter an event. The wristband proves that you've been granted access. When the user's done paying bills, the user closes the window, but does not actually click log out. The user's browser still has the authorization cookie, and their session with the bank is still open. If the user were to open a new browser window and go to the bank's website, they would still be logged in. Now imagine that the user is browsing the web and comes across an image tag where the image source is set to a URL at the same bank. This example transfers money to another account. It's unlikely to be that easy, but it makes the point. This is a URL which a hacker could not use. If they clicked it, it would require a login. But the user is logged in still. When their browser sends a request to that URL, it includes the cookie data that indicates who they are and their previous authentication. So the link works for them. The hacker has taken advantage of the user's logged in state and tricked their browser into taking an action without their knowledge. These examples use GET requests, but it's also possible to craft a form to submit a forged POST request. The user would not need to click submit. In fact, there's no submit button on this form. The form uses CSS to hide, and then JavaScript in the body tag submits the form when the page loads. Unlike the image examples, submitting a form would normally be visible to the user. For example, if a user was tricked into transferring funds, the bank would probably respond with a new webpage which says transfer completed. I think that would make any user suspicious. But the target attribute of this form sends the results to a hidden iframe. The user won't know that a CSRF attack has occurred. Attackers generally use CSRF attacks to make state changing requests. The request performs an action, but the attacker cannot see the results directly since the requests are being performed by other people's browsers. An attacker would just see the results indirectly, a poll being swung in their favor, their bank account suddenly larger, or a configuration is changed from one setting to another. CSRF attacks can have a variety of goals. Some common examples include increasing page views for ad revenue, ballot stuffing on polls, changing a user's password or email address, logging into a site, transferring funds, or downloading malware. For all of these goals, the mechanism of the attack is the same. into making a request to another URL without the user's consent or knowledge.